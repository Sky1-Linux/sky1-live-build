#!/bin/bash
# Sky1 Linux boot updater
#
# Called by kernel postinst/postrm hooks to:
#   1. Copy DTBs from kernel package to /boot/dtbs/
#   2. Regenerate /boot/efi/GRUB/grub.cfg with all installed kernels
#
# Can also be run manually: /usr/share/sky1/update-boot
#
# On dev systems (detected by SKY1-DEV-ENTRIES marker in grub.cfg),
# DTBs are still copied but GRUB regeneration is skipped.

set -e

GRUB_CFG="/boot/efi/GRUB/grub.cfg"
DTB_DIR="/boot/dtbs"
COMPAT_FILE="/sys/firmware/devicetree/base/compatible"

# ── Board detection ──────────────────────────────────────────────────

detect_board_dtb() {
    if [ ! -f "$COMPAT_FILE" ]; then
        echo "sky1-orion-o6.dtb"
        return
    fi

    local compat
    compat=$(tr '\0' '\n' < "$COMPAT_FILE" | head -1)

    case "$compat" in
        radxa,orion-o6n*)
            echo "sky1-orion-o6n.dtb"
            ;;
        radxa,orion-o6*)
            echo "sky1-orion-o6.dtb"
            ;;
        *)
            echo "sky1-orion-o6.dtb"
            echo "Warning: Unknown board '$compat', using O6 DTB" >&2
            ;;
    esac
}

# ── DTB management ───────────────────────────────────────────────────

sync_dtbs() {
    mkdir -p "$DTB_DIR"

    # Copy DTBs for each installed kernel
    for vmlinuz in /boot/vmlinuz-*; do
        [ -f "$vmlinuz" ] || continue
        local ver="${vmlinuz#/boot/vmlinuz-}"
        local src="/usr/lib/linux-image-${ver}/cix"

        if [ -d "$src" ]; then
            cp "$src"/sky1-*.dtb "$DTB_DIR/" 2>/dev/null || true
        fi
    done

    # Remove DTBs for kernels no longer installed
    for dtb in "$DTB_DIR"/sky1-*.dtb; do
        [ -f "$dtb" ] || continue
        local dtb_name
        dtb_name=$(basename "$dtb")
        local found=0

        for vmlinuz in /boot/vmlinuz-*; do
            [ -f "$vmlinuz" ] || continue
            local ver="${vmlinuz#/boot/vmlinuz-}"
            if [ -f "/usr/lib/linux-image-${ver}/cix/${dtb_name}" ]; then
                found=1
                break
            fi
        done

        if [ "$found" = "0" ]; then
            rm -f "$dtb"
        fi
    done
}

# ── GRUB config generation ───────────────────────────────────────────

generate_grub_cfg() {
    local board_dtb="$1"
    local root_uuid

    root_uuid=$(findmnt -n -o UUID /)
    if [ -z "$root_uuid" ]; then
        echo "Error: Could not determine root partition UUID" >&2
        return 1
    fi

    # Collect installed kernels, sorted newest first
    local kernels=()
    while IFS= read -r vmlinuz; do
        [ -f "$vmlinuz" ] || continue
        kernels+=("${vmlinuz#/boot/vmlinuz-}")
    done < <(ls -1 /boot/vmlinuz-* 2>/dev/null | sort -V -r)

    if [ ${#kernels[@]} -eq 0 ]; then
        echo "Error: No kernels found in /boot" >&2
        return 1
    fi

    local newest="${kernels[0]}"

    # Common kernel command line (verbose, no quiet/splash)
    local cmdline_base="loglevel=7 console=tty0 console=ttyAMA2,115200"
    cmdline_base+=" efi=noruntime earlycon=efifb earlycon=pl011,0x040d0000 acpi=off"
    cmdline_base+=" clk_ignore_unused linlon_dp.enable_fb=1 linlon_dp.enable_render=0"
    cmdline_base+=" fbcon=map:01111111 keep_bootcon panic=30"
    cmdline_base+=" root=UUID=${root_uuid} rootwait rw"

    # Build config
    cat << 'PREAMBLE'
# Sky1 Linux GRUB Configuration
# Auto-generated by /usr/share/sky1/update-boot — do not edit manually

set term=vt100
set default=0
set timeout=5

insmod part_gpt
insmod fat
insmod ext2

PREAMBLE

    printf 'search.fs_uuid %s root\n' "$root_uuid"
    printf 'set prefix=($root)/boot/grub\n\n'

    # Newest kernel: normal + recovery
    emit_entry "Sky1 Linux ${newest}" "$board_dtb" "$newest" "$cmdline_base"
    echo
    emit_entry "Sky1 Linux ${newest} (recovery)" "$board_dtb" "$newest" "${cmdline_base} single"

    # Previous kernels (rollback entries)
    local i
    for (( i=1; i<${#kernels[@]}; i++ )); do
        local ver="${kernels[$i]}"
        echo
        emit_entry "Sky1 Linux ${ver} (previous)" "$board_dtb" "$ver" "$cmdline_base"
    done

    echo
}

emit_entry() {
    local title="$1"
    local dtb="$2"
    local ver="$3"
    local cmdline="$4"

    cat << EOF
menuentry '${title}' {
    devicetree (\$root)/boot/dtbs/${dtb}
    linux (\$root)/boot/vmlinuz-${ver} \\
        ${cmdline}
    initrd (\$root)/boot/initrd.img-${ver}
}
EOF
}

# ── Main ─────────────────────────────────────────────────────────────

main() {
    local board_dtb
    board_dtb=$(detect_board_dtb)

    echo "sky1-update-boot: board DTB=${board_dtb}"

    # Always sync DTBs
    sync_dtbs

    # Check for dev system
    if [ -f "$GRUB_CFG" ] && grep -q "SKY1-DEV-ENTRIES" "$GRUB_CFG"; then
        echo "sky1-update-boot: Dev system detected, skipping GRUB regeneration"
        echo "  Run update-dev-boot.py to update GRUB entries"
        return 0
    fi

    # Check EFI mount
    if [ ! -d "/boot/efi/GRUB" ]; then
        echo "sky1-update-boot: /boot/efi/GRUB not found, skipping GRUB regeneration" >&2
        return 0
    fi

    # Generate and write GRUB config
    local new_cfg
    new_cfg=$(generate_grub_cfg "$board_dtb")

    if [ -z "$new_cfg" ]; then
        echo "sky1-update-boot: Failed to generate GRUB config" >&2
        return 1
    fi

    # Backup current config
    if [ -f "$GRUB_CFG" ]; then
        cp "$GRUB_CFG" "${GRUB_CFG}.bak"
    fi

    printf '%s' "$new_cfg" > "$GRUB_CFG"
    sync

    echo "sky1-update-boot: Updated $GRUB_CFG"
}

main "$@"
